# ğŸ” **ç”¨æˆ·è®¤è¯æœºåˆ¶è®¾è®¡æ–¹æ¡ˆ**

> **é¡¹ç›®ï¼š** AIå¯¼å¸ˆå¹³å°  
> **æ¨¡å—ï¼š** ç”¨æˆ·è®¤è¯ç³»ç»Ÿ  
> **ç‰ˆæœ¬ï¼š** v1.0  

---

## ğŸ“‹ **ç›®å½•**

1. [è®¤è¯æ¶æ„è®¾è®¡](#è®¤è¯æ¶æ„è®¾è®¡)
2. [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
3. [åç«¯APIå®ç°](#åç«¯APIå®ç°)
4. [å‰ç«¯å®ç°](#å‰ç«¯å®ç°)
5. [å®‰å…¨ç­–ç•¥](#å®‰å…¨ç­–ç•¥)
6. [ç¬¬ä¸‰æ–¹ç™»å½•](#ç¬¬ä¸‰æ–¹ç™»å½•)

---

## ğŸ—ï¸ **è®¤è¯æ¶æ„è®¾è®¡**

### **è®¤è¯æµç¨‹å›¾**
```
ç”¨æˆ·è®¿é—® â†’ æ£€æŸ¥Token â†’ Tokenæœ‰æ•ˆï¼Ÿ
    â†“              â†“           â†“
  ç™»å½•é¡µ        æ­£å¸¸è®¿é—®    åˆ·æ–°Token
    â†“                           â†“
  ç”¨æˆ·ç™»å½•                   Tokenåˆ·æ–°
    â†“                           â†“
  å‘æ”¾Token                  æ­£å¸¸è®¿é—®
    â†“
  æ­£å¸¸è®¿é—®
```

### **Tokenç­–ç•¥**
```javascript
// JWT Token é…ç½®
const TOKEN_CONFIG = {
  ACCESS_TOKEN: {
    expires: '2h',           // 2å°æ—¶è¿‡æœŸ
    algorithm: 'HS256'       // ç­¾åç®—æ³•
  },
  REFRESH_TOKEN: {
    expires: '7d',           // 7å¤©è¿‡æœŸ
    algorithm: 'HS256'
  }
};

// Token è½½è·ç»“æ„
const tokenPayload = {
  user_id: 'uuid',
  username: 'string',
  subscription_type: 'free|premium',
  permissions: ['chat', 'upload'],
  iat: 'timestamp',         // ç­¾å‘æ—¶é—´
  exp: 'timestamp'          // è¿‡æœŸæ—¶é—´
};
```

---

## ğŸ’¾ **æ•°æ®åº“è®¾è®¡**

### **ç”¨æˆ·è¡¨ (users)**
```sql
CREATE TABLE users (
  id VARCHAR(36) PRIMARY KEY,                    -- UUID
  username VARCHAR(50) NOT NULL UNIQUE,         -- ç”¨æˆ·å
  email VARCHAR(100) NOT NULL UNIQUE,           -- é‚®ç®±
  password_hash VARCHAR(255) NOT NULL,          -- å¯†ç å“ˆå¸Œ
  avatar_url VARCHAR(500),                      -- å¤´åƒURL
  subscription_type ENUM('free', 'premium') DEFAULT 'free',
  status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
  email_verified BOOLEAN DEFAULT FALSE,         -- é‚®ç®±éªŒè¯çŠ¶æ€
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  last_login_at TIMESTAMP NULL,                 -- æœ€åç™»å½•æ—¶é—´
  login_count INT DEFAULT 0,                    -- ç™»å½•æ¬¡æ•°
  
  INDEX idx_email (email),
  INDEX idx_username (username),
  INDEX idx_last_login (last_login_at)
);
```

### **ç”¨æˆ·ä¼šè¯è¡¨ (user_sessions)**
```sql
CREATE TABLE user_sessions (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL,
  refresh_token VARCHAR(500) NOT NULL,          -- åˆ·æ–°ä»¤ç‰Œ
  device_info JSON,                             -- è®¾å¤‡ä¿¡æ¯
  ip_address VARCHAR(45),                       -- IPåœ°å€
  user_agent TEXT,                              -- æµè§ˆå™¨ä¿¡æ¯
  expires_at TIMESTAMP NOT NULL,               -- è¿‡æœŸæ—¶é—´
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  last_used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  is_active BOOLEAN DEFAULT TRUE,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_user_id (user_id),
  INDEX idx_refresh_token (refresh_token),
  INDEX idx_expires_at (expires_at)
);
```

### **ç¬¬ä¸‰æ–¹ç™»å½•è¡¨ (oauth_accounts)**
```sql
CREATE TABLE oauth_accounts (
  id VARCHAR(36) PRIMARY KEY,
  user_id VARCHAR(36) NOT NULL,
  provider ENUM('wechat', 'qq', 'github') NOT NULL,
  provider_user_id VARCHAR(100) NOT NULL,      -- ç¬¬ä¸‰æ–¹ç”¨æˆ·ID
  provider_username VARCHAR(100),              -- ç¬¬ä¸‰æ–¹ç”¨æˆ·å
  access_token VARCHAR(500),                   -- ç¬¬ä¸‰æ–¹è®¿é—®ä»¤ç‰Œ
  refresh_token VARCHAR(500),                  -- ç¬¬ä¸‰æ–¹åˆ·æ–°ä»¤ç‰Œ
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  UNIQUE KEY unique_provider_user (provider, provider_user_id),
  INDEX idx_user_id (user_id)
);
```

---

## ğŸ”§ **åç«¯APIå®ç°**

### **è®¤è¯ä¸­é—´ä»¶**
```javascript
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// JWTå·¥å…·ç±»
class JWTUtil {
  static generateTokens(payload) {
    const accessToken = jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: '2h',
      algorithm: 'HS256'
    });
    
    const refreshToken = jwt.sign(
      { user_id: payload.user_id, type: 'refresh' },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    return { accessToken, refreshToken };
  }
  
  static verifyAccessToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      throw new Error('Invalid access token');
    }
  }
  
  static verifyRefreshToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_REFRESH_SECRET);
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }
}

// è®¤è¯ä¸­é—´ä»¶
const authenticateToken = async (req, res, next) => {
  try {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
      return res.status(401).json({ error: 'Access token required' });
    }
    
    const payload = JWTUtil.verifyAccessToken(token);
    
    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    const user = await User.findById(payload.user_id);
    if (!user || user.status !== 'active') {
      return res.status(401).json({ error: 'User not found or inactive' });
    }
    
    req.user = payload;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
};
```

### **ç”¨æˆ·æ³¨å†ŒAPI**
```javascript
// POST /api/auth/register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // æ•°æ®éªŒè¯
    if (!username || !email || !password) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    if (password.length < 6) {
      return res.status(400).json({ error: 'Password must be at least 6 characters' });
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await User.findOne({
      $or: [{ email }, { username }]
    });
    
    if (existingUser) {
      return res.status(409).json({ error: 'User already exists' });
    }
    
    // å¯†ç åŠ å¯†
    const passwordHash = await bcrypt.hash(password, 12);
    
    // åˆ›å»ºç”¨æˆ·
    const userId = generateUUID();
    const user = await User.create({
      id: userId,
      username,
      email,
      password_hash: passwordHash,
      subscription_type: 'free',
      status: 'active'
    });
    
    // ç”ŸæˆToken
    const tokenPayload = {
      user_id: userId,
      username,
      subscription_type: 'free',
      permissions: ['chat']
    };
    
    const { accessToken, refreshToken } = JWTUtil.generateTokens(tokenPayload);
    
    // ä¿å­˜ä¼šè¯
    await UserSession.create({
      id: generateUUID(),
      user_id: userId,
      refresh_token: refreshToken,
      device_info: getDeviceInfo(req),
      ip_address: req.ip,
      user_agent: req.get('User-Agent'),
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7å¤©
    });
    
    // åŸ‹ç‚¹ï¼šç”¨æˆ·æ³¨å†Œ
    trackEvent({
      event_name: 'user_auth',
      event_type: 'register',
      user_id: userId,
      method: 'email',
      ip_address: req.ip,
      user_agent: req.get('User-Agent')
    });
    
    res.status(201).json({
      success: true,
      user: {
        id: userId,
        username,
        email,
        subscription_type: 'free'
      },
      tokens: {
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_in: 7200 // 2å°æ—¶
      }
    });
    
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### **ç”¨æˆ·ç™»å½•API**
```javascript
// POST /api/auth/login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }
    
    // æŸ¥æ‰¾ç”¨æˆ·
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if (user.status !== 'active') {
      return res.status(401).json({ error: 'Account is inactive or banned' });
    }
    
    // éªŒè¯å¯†ç 
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // ç”ŸæˆToken
    const tokenPayload = {
      user_id: user.id,
      username: user.username,
      subscription_type: user.subscription_type,
      permissions: getPermissions(user.subscription_type)
    };
    
    const { accessToken, refreshToken } = JWTUtil.generateTokens(tokenPayload);
    
    // æ›´æ–°ç”¨æˆ·ç™»å½•ä¿¡æ¯
    await User.update(user.id, {
      last_login_at: new Date(),
      login_count: user.login_count + 1
    });
    
    // æ¸…ç†æ—§ä¼šè¯ï¼ˆå¯é€‰ï¼šé™åˆ¶åŒæ—¶ç™»å½•è®¾å¤‡æ•°ï¼‰
    await UserSession.deleteExpiredSessions(user.id);
    
    // åˆ›å»ºæ–°ä¼šè¯
    await UserSession.create({
      id: generateUUID(),
      user_id: user.id,
      refresh_token: refreshToken,
      device_info: getDeviceInfo(req),
      ip_address: req.ip,
      user_agent: req.get('User-Agent'),
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
    });
    
    // åŸ‹ç‚¹ï¼šç”¨æˆ·ç™»å½•
    trackEvent({
      event_name: 'user_auth',
      event_type: 'login',
      user_id: user.id,
      method: 'email',
      login_success: true,
      ip_address: req.ip,
      user_agent: req.get('User-Agent')
    });
    
    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        subscription_type: user.subscription_type,
        avatar_url: user.avatar_url
      },
      tokens: {
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_in: 7200
      }
    });
    
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});
```

### **Tokenåˆ·æ–°API**
```javascript
// POST /api/auth/refresh
app.post('/api/auth/refresh', async (req, res) => {
  try {
    const { refresh_token } = req.body;
    
    if (!refresh_token) {
      return res.status(400).json({ error: 'Refresh token required' });
    }
    
    // éªŒè¯åˆ·æ–°ä»¤ç‰Œ
    const payload = JWTUtil.verifyRefreshToken(refresh_token);
    
    // æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨ä¸”æœ‰æ•ˆ
    const session = await UserSession.findOne({
      user_id: payload.user_id,
      refresh_token: refresh_token,
      is_active: true
    });
    
    if (!session || session.expires_at < new Date()) {
      return res.status(401).json({ error: 'Invalid or expired refresh token' });
    }
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await User.findById(payload.user_id);
    if (!user || user.status !== 'active') {
      return res.status(401).json({ error: 'User not found or inactive' });
    }
    
    // ç”Ÿæˆæ–°çš„è®¿é—®ä»¤ç‰Œ
    const newTokenPayload = {
      user_id: user.id,
      username: user.username,
      subscription_type: user.subscription_type,
      permissions: getPermissions(user.subscription_type)
    };
    
    const { accessToken } = JWTUtil.generateTokens(newTokenPayload);
    
    // æ›´æ–°ä¼šè¯æœ€åä½¿ç”¨æ—¶é—´
    await UserSession.update(session.id, {
      last_used_at: new Date()
    });
    
    res.json({
      success: true,
      access_token: accessToken,
      expires_in: 7200
    });
    
  } catch (error) {
    console.error('Token refresh error:', error);
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});
```

---

## ğŸ’» **å‰ç«¯å®ç°**

### **è®¤è¯ç®¡ç†ç±»**
```javascript
class AuthManager {
  constructor() {
    this.accessToken = localStorage.getItem('access_token');
    this.refreshToken = localStorage.getItem('refresh_token');
    this.user = JSON.parse(localStorage.getItem('user') || 'null');
    this.isRefreshing = false;
    this.failedQueue = [];
  }
  
  // ç™»å½•
  async login(email, password) {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      const data = await response.json();
      
      if (data.success) {
        this.setTokens(data.tokens);
        this.setUser(data.user);
        return { success: true, user: data.user };
      } else {
        return { success: false, error: data.error };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  // æ³¨å†Œ
  async register(username, email, password) {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, email, password })
      });
      
      const data = await response.json();
      
      if (data.success) {
        this.setTokens(data.tokens);
        this.setUser(data.user);
        return { success: true, user: data.user };
      } else {
        return { success: false, error: data.error };
      }
    } catch (error) {
      return { success: false, error: 'Network error' };
    }
  }
  
  // é€€å‡ºç™»å½•
  logout() {
    this.accessToken = null;
    this.refreshToken = null;
    this.user = null;
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    localStorage.removeItem('user');
    
    // è·³è½¬åˆ°ç™»å½•é¡µ
    window.location.href = '/login';
  }
  
  // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
  isAuthenticated() {
    return !!this.accessToken && !!this.user;
  }
  
  // è·å–å½“å‰ç”¨æˆ·
  getCurrentUser() {
    return this.user;
  }
  
  // è®¾ç½®ä»¤ç‰Œ
  setTokens(tokens) {
    this.accessToken = tokens.access_token;
    this.refreshToken = tokens.refresh_token;
    localStorage.setItem('access_token', tokens.access_token);
    localStorage.setItem('refresh_token', tokens.refresh_token);
  }
  
  // è®¾ç½®ç”¨æˆ·ä¿¡æ¯
  setUser(user) {
    this.user = user;
    localStorage.setItem('user', JSON.stringify(user));
  }
  
  // åˆ·æ–°ä»¤ç‰Œ
  async refreshAccessToken() {
    if (this.isRefreshing) {
      return new Promise((resolve, reject) => {
        this.failedQueue.push({ resolve, reject });
      });
    }
    
    this.isRefreshing = true;
    
    try {
      const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refresh_token: this.refreshToken })
      });
      
      const data = await response.json();
      
      if (data.success) {
        this.accessToken = data.access_token;
        localStorage.setItem('access_token', data.access_token);
        
        // å¤„ç†å¤±è´¥é˜Ÿåˆ—
        this.failedQueue.forEach(({ resolve }) => resolve(data.access_token));
        this.failedQueue = [];
        
        return data.access_token;
      } else {
        this.logout();
        throw new Error('Refresh failed');
      }
    } catch (error) {
      this.failedQueue.forEach(({ reject }) => reject(error));
      this.failedQueue = [];
      this.logout();
      throw error;
    } finally {
      this.isRefreshing = false;
    }
  }
  
  // å¸¦è®¤è¯çš„è¯·æ±‚
  async authenticatedFetch(url, options = {}) {
    const headers = {
      'Content-Type': 'application/json',
      ...options.headers
    };
    
    if (this.accessToken) {
      headers['Authorization'] = `Bearer ${this.accessToken}`;
    }
    
    let response = await fetch(url, {
      ...options,
      headers
    });
    
    // å¦‚æœTokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
    if (response.status === 401 && this.refreshToken) {
      try {
        await this.refreshAccessToken();
        headers['Authorization'] = `Bearer ${this.accessToken}`;
        response = await fetch(url, {
          ...options,
          headers
        });
      } catch (error) {
        // åˆ·æ–°å¤±è´¥ï¼Œé‡å®šå‘åˆ°ç™»å½•é¡µ
        this.logout();
        throw error;
      }
    }
    
    return response;
  }
}

// å…¨å±€å®ä¾‹
const auth = new AuthManager();
```

### **è·¯ç”±å®ˆå«**
```javascript
// è·¯ç”±å®ˆå«ä¸­é—´ä»¶
function requireAuth(to, from, next) {
  if (auth.isAuthenticated()) {
    next();
  } else {
    next('/login');
  }
}

// Vue Router é…ç½®
const routes = [
  { path: '/login', component: LoginPage },
  { path: '/register', component: RegisterPage },
  { 
    path: '/dashboard', 
    component: Dashboard, 
    beforeEnter: requireAuth 
  },
  { 
    path: '/chat', 
    component: ChatPage, 
    beforeEnter: requireAuth 
  }
];
```

---

## ğŸ”’ **å®‰å…¨ç­–ç•¥**

### **å¯†ç å®‰å…¨**
```javascript
// å¯†ç å¼ºåº¦éªŒè¯
function validatePasswordStrength(password) {
  const rules = [
    { test: /.{8,}/, message: 'è‡³å°‘8ä¸ªå­—ç¬¦' },
    { test: /[A-Z]/, message: 'è‡³å°‘1ä¸ªå¤§å†™å­—æ¯' },
    { test: /[a-z]/, message: 'è‡³å°‘1ä¸ªå°å†™å­—æ¯' },
    { test: /\d/, message: 'è‡³å°‘1ä¸ªæ•°å­—' },
    { test: /[!@#$%^&*]/, message: 'è‡³å°‘1ä¸ªç‰¹æ®Šå­—ç¬¦' }
  ];
  
  const errors = rules
    .filter(rule => !rule.test.test(password))
    .map(rule => rule.message);
    
  return {
    isValid: errors.length === 0,
    errors
  };
}

// bcrypté…ç½®
const BCRYPT_ROUNDS = 12; // æ›´é«˜çš„å®‰å…¨çº§åˆ«
```

### **ç™»å½•é™åˆ¶**
```javascript
// ç™»å½•å¤±è´¥é™åˆ¶
class LoginLimiter {
  constructor() {
    this.attempts = new Map(); // IP -> { count, lastAttempt }
    this.MAX_ATTEMPTS = 5;
    this.LOCKOUT_TIME = 15 * 60 * 1000; // 15åˆ†é’Ÿ
  }
  
  isBlocked(ip) {
    const record = this.attempts.get(ip);
    if (!record) return false;
    
    const now = Date.now();
    if (now - record.lastAttempt > this.LOCKOUT_TIME) {
      this.attempts.delete(ip);
      return false;
    }
    
    return record.count >= this.MAX_ATTEMPTS;
  }
  
  recordFailure(ip) {
    const record = this.attempts.get(ip) || { count: 0, lastAttempt: 0 };
    record.count++;
    record.lastAttempt = Date.now();
    this.attempts.set(ip, record);
  }
  
  recordSuccess(ip) {
    this.attempts.delete(ip);
  }
}
```

### **CSRFé˜²æŠ¤**
```javascript
const csrf = require('csurf');

// CSRFä¸­é—´ä»¶
app.use(csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
}));

// CSRF Token ç«¯ç‚¹
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrf_token: req.csrfToken() });
});
```

---

## ğŸ”— **ç¬¬ä¸‰æ–¹ç™»å½•**

### **å¾®ä¿¡ç™»å½•**
```javascript
// å¾®ä¿¡OAuthé…ç½®
const WECHAT_CONFIG = {
  app_id: process.env.WECHAT_APP_ID,
  app_secret: process.env.WECHAT_APP_SECRET,
  redirect_uri: process.env.WECHAT_REDIRECT_URI
};

// å¾®ä¿¡ç™»å½•å›è°ƒ
app.get('/api/auth/wechat/callback', async (req, res) => {
  try {
    const { code } = req.query;
    
    // è·å–access_token
    const tokenResponse = await fetch(
      `https://api.weixin.qq.com/sns/oauth2/access_token?appid=${WECHAT_CONFIG.app_id}&secret=${WECHAT_CONFIG.app_secret}&code=${code}&grant_type=authorization_code`
    );
    const tokenData = await tokenResponse.json();
    
    if (tokenData.errcode) {
      return res.status(400).json({ error: 'WeChat auth failed' });
    }
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const userResponse = await fetch(
      `https://api.weixin.qq.com/sns/userinfo?access_token=${tokenData.access_token}&openid=${tokenData.openid}&lang=zh_CN`
    );
    const wechatUser = await userResponse.json();
    
    // æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
    let user = await findUserByWechat(tokenData.openid);
    
    if (!user) {
      // åˆ›å»ºæ–°ç”¨æˆ·
      const userId = generateUUID();
      user = await User.create({
        id: userId,
        username: wechatUser.nickname,
        email: null, // å¾®ä¿¡ç™»å½•å¯èƒ½æ²¡æœ‰é‚®ç®±
        password_hash: null, // ç¬¬ä¸‰æ–¹ç™»å½•æ— å¯†ç 
        avatar_url: wechatUser.headimgurl,
        subscription_type: 'free',
        status: 'active'
      });
      
      // ä¿å­˜å¾®ä¿¡è´¦å·å…³è”
      await OAuthAccount.create({
        id: generateUUID(),
        user_id: userId,
        provider: 'wechat',
        provider_user_id: tokenData.openid,
        provider_username: wechatUser.nickname,
        access_token: tokenData.access_token,
        refresh_token: tokenData.refresh_token,
        expires_at: new Date(Date.now() + tokenData.expires_in * 1000)
      });
    }
    
    // ç”ŸæˆJWT Token
    const tokenPayload = {
      user_id: user.id,
      username: user.username,
      subscription_type: user.subscription_type,
      permissions: getPermissions(user.subscription_type)
    };
    
    const { accessToken, refreshToken } = JWTUtil.generateTokens(tokenPayload);
    
    // é‡å®šå‘åˆ°å‰ç«¯ï¼Œæºå¸¦token
    res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${accessToken}&refresh=${refreshToken}`);
    
  } catch (error) {
    console.error('WeChat auth error:', error);
    res.redirect(`${process.env.FRONTEND_URL}/login?error=wechat_failed`);
  }
});
```

---

## ğŸ“ **æ€»ç»“**

è¿™å¥—è®¤è¯æœºåˆ¶å…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹ï¼š

âœ… **å®‰å…¨æ€§é«˜**ï¼šJWT + bcrypt + CSRFé˜²æŠ¤  
âœ… **ç”¨æˆ·ä½“éªŒå¥½**ï¼šè‡ªåŠ¨åˆ·æ–°Tokenï¼Œæ— æ„ŸçŸ¥ç™»å½•  
âœ… **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒç¬¬ä¸‰æ–¹ç™»å½•ï¼Œæ˜“äºæ·»åŠ æ–°çš„è®¤è¯æ–¹å¼  
âœ… **ç›‘æ§å®Œå–„**ï¼šå®Œæ•´çš„ç™»å½•åŸ‹ç‚¹å’Œå®‰å…¨æ—¥å¿—  

**éƒ¨ç½²å»ºè®®ï¼š**
1. ç”Ÿäº§ç¯å¢ƒä½¿ç”¨HTTPS
2. å®šæœŸæ›´æ–°JWTå¯†é’¥
3. ç›‘æ§å¼‚å¸¸ç™»å½•è¡Œä¸º
4. å¤‡ä»½ç”¨æˆ·æ•°æ® 